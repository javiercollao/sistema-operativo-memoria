<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.17.0/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.17.0/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.17.0/dist/index.js"></script><script>(()=>{setTimeout(()=>{const{markmap:O,mm:h}=window,M=new O.Toolbar;M.attach(h);const re=M.render();re.setAttribute("style","position:absolute;bottom:20px;right:20px"),document.body.append(re)})})()</script><script>((i,L,f,o)=>{const w=i();window.mm=w.Markmap.create("svg#mindmap",(L||w.deriveOptions)(o),f)})(()=>window.markmap,null,{"content":"Mapa Mental: Memoria Virtual","children":[{"content":"Motivcacion:","children":[{"content":"al poder administar la memoria principal con segmentacion o paginacion, la limitante de esto, es que todas las páginas o segmentos deben estar en memoria principal para ejecutar un proceso determinado.","children":[],"payload":{"lines":"5,7"}}],"payload":{"lines":"4,5"}},{"content":"Fundamentos Memoria Virtual","children":[{"content":"<strong>Nuevo Proceso a Memoria</strong>","children":[{"content":"SO inicia trayendo una o dos porciones (paginas o segmentos) del programa y datos.","children":[],"payload":{"lines":"9,10"}}],"payload":{"lines":"8,10"}},{"content":"<strong>Conjunto Residente</strong>","children":[{"content":"Porciones del proceso en memoria principal.","children":[],"payload":{"lines":"11,12"}},{"content":"Permite ejecucion sin problemas si contiene todas las porciones necesarias.","children":[],"payload":{"lines":"12,13"}}],"payload":{"lines":"10,13"}},{"content":"<strong>Interrupcion por I/O</strong>","children":[{"content":"SO interrumpe el proceso para traer porciones necesarias desde el disco.","children":[],"payload":{"lines":"14,15"}}],"payload":{"lines":"13,15"}},{"content":"Nos permite cargar procesos mas grandes ya que la memoria secudaria funciona como una extencion de la principal, si bien en ese sector no se pueden ejecutar pero si cargar .","children":[],"payload":{"lines":"15,17"}}],"payload":{"lines":"7,8"}},{"content":"Tabla de Paginas o Segmentos","children":[{"content":"<strong>Referencia</strong>","children":[{"content":"Permite al SO saber si una referencia esta en el conjunto residente.","children":[],"payload":{"lines":"19,21"}}],"payload":{"lines":"18,21"}}],"payload":{"lines":"17,18"}},{"content":"Proximidad y Memoria Virtual","children":[{"content":"<strong>Multiprogramacion</strong>","children":[{"content":"Necesidad de mantener suficientes porciones en memoria para evitar rendimiento bajo.","children":[],"payload":{"lines":"23,24"}}],"payload":{"lines":"22,24"}},{"content":"<strong>Trashing</strong>","children":[{"content":"ocurre cuando el sistema pasa mas tiempo intercambiando porciones que ejecutando procesos.","children":[],"payload":{"lines":"25,26"}}],"payload":{"lines":"24,26"}},{"content":"<strong>Principio de Proximidad</strong>","children":[{"content":"Referencias a programa y datos tienden a agruparse.","children":[],"payload":{"lines":"27,28"}},{"content":"Permite hacer suposiciones sobre porciones necesarias en el futuro.","children":[],"payload":{"lines":"28,30"}}],"payload":{"lines":"26,30"}}],"payload":{"lines":"21,22"}},{"content":"Paginacion y Segmentacion en Memoria Virtual","children":[{"content":"<strong>Caracteristicas Necesarias que deben existir para que funcione</strong>","children":[{"content":"Soporte de hardware para paginacion y/o segmentacion.","children":[],"payload":{"lines":"32,33"}},{"content":"SO con funciones para gestionar movimiento de paginas/segmentos.","children":[],"payload":{"lines":"33,34"}}],"payload":{"lines":"31,34"}},{"content":"<strong>Tabla de Paginas</strong>","children":[{"content":"Modificacion con bits de presencia (P) y modificacion (M).","children":[],"payload":{"lines":"35,36"}},{"content":"Tamaño variable, guardada en memoria principal.","children":[],"payload":{"lines":"36,38"}}],"payload":{"lines":"34,38"}}],"payload":{"lines":"30,31"}},{"content":"Paginacion","children":[{"content":"<strong>Traduccion de Direcciones</strong>","children":[{"content":"Uso de tabla de paginas para convertir direccion virtual a fisica.","children":[],"payload":{"lines":"40,41"}}],"payload":{"lines":"39,41"}},{"content":"<strong>Tabla de Paginas de Dos Niveles</strong>","children":[{"content":"Manejo de grandes tablas de paginas, reduccion de uso de memoria (pagina la tabla pagina, se carga en memoria la tabla que se va usar).","children":[],"payload":{"lines":"42,43"}},{"content":"Desde el programa se indica ir a la dir de la tabla pag. raiz luego a la dir. tabla de pagina, y finalmente al marco de pagina .","children":[],"payload":{"lines":"43,44"}}],"payload":{"lines":"41,44"}},{"content":"<strong>Tabla de Paginas Invertida</strong>","children":[{"content":"Entrada por cada marco en memoria, uso de funcion de hash.","children":[],"payload":{"lines":"45,46"}},{"content":"Desde el program se indica ir a la dir con hash, puede que 2 pagina se carguen a la mimsa dir. es por eso qe se compara si es la pagina que se necesita, finalmente se direge hacia numero de marco con el desplazamiento.","children":[],"payload":{"lines":"46,47"}}],"payload":{"lines":"44,47"}},{"content":"<strong>Buffer de Traduccion Anticipada (TLB)</strong>","children":[{"content":"Cache para entradas de la tabla de paginas, mejora tiempo de acceso a memoria.","children":[],"payload":{"lines":"48,49"}},{"content":"si esta en la TLB, si esta se genera la direccion fisica en mem principal(cpu)","children":[],"payload":{"lines":"49,50"}},{"content":"si no esta en la TLB, entonces se busca si se encuentra en la memoria principal","children":[],"payload":{"lines":"50,51"}},{"content":"si no esta en la TLB y tampoco en la memoria principal, entonces va a preguntar a memoria secundaria y la carga en memoria principal, se tiene que actualizar la TLB y la tabla de pagina.","children":[],"payload":{"lines":"51,52"}},{"content":"En caso deestar en la TLB o tabla de paginas, se busca primero en la cache del sistema entonces desde la tabla de pagina o TLB se consulta si esta en cache del sistema y si no esta luego se busca en memoria principal.","children":[],"payload":{"lines":"52,54"}}],"payload":{"lines":"47,54"}}],"payload":{"lines":"38,39"}},{"content":"Tamaño de la Pagina","children":[{"content":"<strong>Decision Importante</strong>","children":[{"content":"Minimizar fragmentacion interna.","children":[],"payload":{"lines":"56,57"}},{"content":"Paginas mas grandes, menos fragmentacion interna, menos entradas en la tabla de paginas.","children":[],"payload":{"lines":"57,59"}}],"payload":{"lines":"55,59"}}],"payload":{"lines":"54,55"}},{"content":"Segmentacion","children":[{"content":"<strong>Diferentes Espacios o Segmentos</strong>","children":[{"content":"Facilita tratamiento y proteccion de datos. (solo para lectura, escritura, que usuarios pueden modificar, etc)","children":[],"payload":{"lines":"61,62"}},{"content":"Permite comparticion eficiente entre procesos.","children":[],"payload":{"lines":"62,63"}},{"content":"Necesito saber cual es la extension del segmento y donde comienza.","children":[],"payload":{"lines":"63,65"}}],"payload":{"lines":"60,65"}}],"payload":{"lines":"59,60"}},{"content":"Segmentacion y Paginacion","children":[{"content":"<strong>Combinacion de Tecnicas</strong>","children":[{"content":"Segmentacion para organizacion logica.","children":[],"payload":{"lines":"67,68"}},{"content":"se utiliza una tabla de segmentacion","children":[],"payload":{"lines":"68,69"}},{"content":"Paginacion para administracion fisica de la memoria.","children":[],"payload":{"lines":"69,70"}},{"content":"y luego utilizamos tabla de paginas","children":[],"payload":{"lines":"70,71"}},{"content":"no todo el segmento esta en memoria principal, solo partes (paginado)","children":[],"payload":{"lines":"71,73"}}],"payload":{"lines":"66,73"}}],"payload":{"lines":"65,66"}},{"content":"Politicas de Memoria Virtual","children":[{"content":"<strong>Politica de Recuperacion</strong>","children":[{"content":"Determina cuando se trae una pagina a memoria principal (bajo demanda o anticipada).","children":[],"payload":{"lines":"75,76"}}],"payload":{"lines":"74,76"}},{"content":"<strong>Politica de Ubicacion</strong>","children":[{"content":"Determina ubicacion de porciones de memoria en la memoria real con los algoritmos best-fit, first-fit, next-fit.","children":[],"payload":{"lines":"77,78"}}],"payload":{"lines":"76,78"}},{"content":"<strong>Politica de Reemplazo</strong>","children":[{"content":"Define que pagina reemplazar (algoritmos: Optimo, LRU, FIFO, Reloj), elegimos la que tiene menos posibilidad de volver a usarla para no caer en trashing .","children":[{"content":"Optimo: asume cuales seran las siguientes refencias de las paginas(pero no lo sabemos), se reemplazara la pagina que menos probabilidad tendra este algorimo es teorico","children":[],"payload":{"lines":"80,81"}},{"content":"LRU: reemplazara la pagina que no a sido referenciada en un largo tiempo","children":[],"payload":{"lines":"81,82"}},{"content":"FIFO: reemplaza la primera pagina que ingreso","children":[],"payload":{"lines":"82,83"}},{"content":"reloj: se agrega un bit de uso en cada marco, cada vez que se usa se coloca en 1","children":[],"payload":{"lines":"83,84"}}],"payload":{"lines":"79,84"}}],"payload":{"lines":"78,84"}},{"content":"<strong>Gestion del Conjunto Residente</strong>","children":[{"content":"Define cuantas paginas cargar en memoria principal (asignacion fija o variable).","children":[],"payload":{"lines":"85,86"}}],"payload":{"lines":"84,86"}},{"content":"<strong>Politica de Limpieza</strong>","children":[{"content":"Establece cuando escribir una pagina modificada en memoria secundaria.","children":[],"payload":{"lines":"87,88"}}],"payload":{"lines":"86,88"}},{"content":"<strong>Control de Carga</strong>","children":[{"content":"Determina numero de procesos en memoria principal para evitar thrashing.","children":[],"payload":{"lines":"89,90"}}],"payload":{"lines":"88,90"}}],"payload":{"lines":"73,74"}}],"payload":{"lines":"1,2"}},{"colorFreezeLevel":2})</script>
</body>
</html>
