<!DOCTYPE html>
<html>
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">
<title>Markmap</title>
<style>
* {
  margin: 0;
  padding: 0;
}
#mindmap {
  display: block;
  width: 100vw;
  height: 100vh;
}
</style>
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.17.0/dist/style.css">
</head>
<body>
<svg id="mindmap"></svg>
<script src="https://cdn.jsdelivr.net/npm/d3@7.8.5/dist/d3.min.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-view@0.17.0/dist/browser/index.js"></script><script src="https://cdn.jsdelivr.net/npm/markmap-toolbar@0.17.0/dist/index.js"></script><script>(()=>{setTimeout(()=>{const{markmap:O,mm:h}=window,M=new O.Toolbar;M.attach(h);const re=M.render();re.setAttribute("style","position:absolute;bottom:20px;right:20px"),document.body.append(re)})})()</script><script>((i,L,f,o)=>{const w=i();window.mm=w.Markmap.create("svg#mindmap",(L||w.deriveOptions)(o),f)})(()=>window.markmap,null,{"content":"Mapa Mental: Gestion de Memoria","children":[{"content":"Motivcacion:","children":[{"content":"como la mem se debe acomodar a multiples procesos en ejecucion, el SO se encargan de aprovechar los recursos del cpu (considerando: necesidades del sistema y entendimiento logico de memoria, este ultimo quiere decir como el software mapea a la memoria fisica)","children":[],"payload":{"lines":"3,4"}}],"payload":{"lines":"2,3"}},{"content":"Requisitos de la Gestion de Memoria","children":[{"content":"<strong>Reubicacion</strong>","children":[{"content":"En el proceso de intercambiado entre memoria secundaria y principal durante la ejecucion el proceso se cargara (partes) a esta ultima en sectores distintos.","children":[],"payload":{"lines":"6,7"}}],"payload":{"lines":"5,7"}},{"content":"<strong>Proteccion</strong>","children":[{"content":"Proteccion contra interferencias por partes de otros procesos (no deseadas), comprobacion de referencias en tiempo de ejecucion (por parte del hardware).","children":[],"payload":{"lines":"8,9"}}],"payload":{"lines":"7,9"}},{"content":"<strong>Comparticion</strong>","children":[{"content":"Permitir acceso a la misma porcion de memoria por varios procesos sin comprometer la proteccion.","children":[],"payload":{"lines":"10,11"}}],"payload":{"lines":"9,11"}},{"content":"<strong>Organizacion Logica</strong>","children":[{"content":"Programas organizados en modulos, division logica usando paginacion y segmentacion.","children":[],"payload":{"lines":"12,13"}}],"payload":{"lines":"11,13"}},{"content":"<strong>Organizacion Fisica</strong>","children":[{"content":"Memoria organizada en niveles jerarquicos, movimiento de instrucciones y datos por el S.O.","children":[],"payload":{"lines":"14,16"}}],"payload":{"lines":"13,16"}}],"payload":{"lines":"4,5"}},{"content":"Particionamiento de la Memoria","children":[{"content":"<strong>Particionamiento Fijo</strong>","children":[{"content":"<strong>Tamaños de la Particion</strong>","children":[{"content":"Igual o variable tamaño, problema de fragmentacion interna","children":[],"payload":{"lines":"19,20"}},{"content":"un proceso se puede cargar aqui solo si es menor o igual al tamaño de particion, pero si es muy pequeño, lo que sobra de la particion es la frgmentaion interna.","children":[],"payload":{"lines":"20,21"}}],"payload":{"lines":"18,21"}},{"content":"<strong>Algoritmo de Ubicacion</strong>","children":[{"content":"Igual tamaño: ubicacion trivial.","children":[],"payload":{"lines":"22,23"}},{"content":"Tamaño variable: mejor ajuste del proceso, uso de una o varias colas .","children":[],"payload":{"lines":"23,24"}}],"payload":{"lines":"21,24"}}],"payload":{"lines":"17,24"}},{"content":"<strong>Particionamiento Dinamico</strong>","children":[{"content":"Particiones de longitud y numero variable, asignacion de memoria necesaria al llegar un proceso (no hay frag. interna).","children":[],"payload":{"lines":"25,26"}},{"content":"<strong>Fragmentacion Externa: espacios libres de sectores de mem discontinuos</strong>","children":[{"content":"Compactacion como solucion, costosa y lenta.","children":[],"payload":{"lines":"27,28"}}],"payload":{"lines":"26,28"}},{"content":"<strong>Algoritmo de Ubicacion</strong>","children":[{"content":"Busca minimizar fragmentacion externa, algoritmos:","children":[{"content":"best-fit: busca un area de memoria que mejor se ajusta a las necesidades del proceso","children":[],"payload":{"lines":"30,31"}},{"content":"first-fist: busca desde la primera posicion de la memoria un area conveniente y el primero que encuentra es elegido","children":[],"payload":{"lines":"31,32"}},{"content":"next-fit : busca desde el ultimo bloque que se asigno, luego el primer espacio que encuentra es elegido","children":[],"payload":{"lines":"32,33"}}],"payload":{"lines":"29,33"}}],"payload":{"lines":"28,33"}},{"content":"<strong>Sistema Buddy</strong>","children":[{"content":"Bloques de memoria de tamaño 2^u, asignacion de bloques de tamaño entero si no sobrepasa el tamaño, si no se empieza a dividir en  bloques en mitades hasta encontrar un tamaño conveniente.","children":[],"payload":{"lines":"34,36"}}],"payload":{"lines":"33,36"}}],"payload":{"lines":"24,36"}}],"payload":{"lines":"16,17"}},{"content":"Tipos de Direcciones","children":[{"content":"<strong>Direccion Logica</strong>","children":[{"content":"Referencia a la direccion de memoria, independiente de la asignacion actual, debe traducirse a direccion fisica.","children":[],"payload":{"lines":"38,39"}}],"payload":{"lines":"37,39"}},{"content":"<strong>Direccion Relativa</strong>","children":[{"content":"Tipo especial de direccion logica, ubicacion relativa a un punto conocido, funciona como un puntero para moverme se posicion .","children":[],"payload":{"lines":"40,41"}}],"payload":{"lines":"39,41"}},{"content":"<strong>Direccion Fisica</strong>","children":[{"content":"Ubicacion real en la memoria.","children":[],"payload":{"lines":"42,44"}}],"payload":{"lines":"41,44"}}],"payload":{"lines":"36,37"}},{"content":"Carga y Enlace","children":[{"content":"<strong>Carga</strong>","children":[{"content":"<strong>Carga Absoluta</strong>","children":[{"content":"Siempre en la misma ubicacion de memoria, direcciones absolutas (por ejemplo el S.O se carga en un lugar especifico, tiene una memoria limitada para el).","children":[],"payload":{"lines":"47,48"}}],"payload":{"lines":"46,48"}},{"content":"<strong>Carga Reubicable</strong>","children":[{"content":"Direcciones relativas a un punto conocido del proceso.","children":[],"payload":{"lines":"49,50"}}],"payload":{"lines":"48,50"}},{"content":"<strong>Carga Dinamica</strong>","children":[{"content":"Procesos intercambiados entre memoria principal y secundaria, referencias como direcciones relativas.","children":[],"payload":{"lines":"51,52"}}],"payload":{"lines":"50,52"}}],"payload":{"lines":"45,52"}},{"content":"<strong>Enlace</strong>","children":[{"content":"Referencias entre modulos de un programa, resolucion de direcciones relativas a direcciones fisicas.","children":[],"payload":{"lines":"53,54"}},{"content":"<strong>Funcion de Montaje</strong>","children":[{"content":"Ensamblaje de modulos con referencias externas, tabla de enlaces para traducir direcciones relativas.","children":[],"payload":{"lines":"55,57"}}],"payload":{"lines":"54,57"}}],"payload":{"lines":"52,57"}}],"payload":{"lines":"44,45"}},{"content":"Paginacion","children":[{"content":"Memoria principal dividida en marcos y los procesos divididos en paginas.","children":[],"payload":{"lines":"58,59"}},{"content":"<strong>Asignacion de Paginas a Marcos</strong>","children":[{"content":"Resolucion de fragmentacion interna (solo podria presentar frag int. el ultimo marco asignado a un proceso).","children":[],"payload":{"lines":"60,61"}},{"content":"Traduccion de direcciones logicas a fisicas usando direccion de pagina y offset.","children":[],"payload":{"lines":"61,62"}},{"content":"no es necesario que los procesos esten continuas en memoria , gracias a la direcciones relativas","children":[],"payload":{"lines":"62,63"}}],"payload":{"lines":"59,63"}},{"content":"<strong>Tamaño de Paginas y Marcos</strong>","children":[{"content":"Potencia de 2.","children":[],"payload":{"lines":"64,65"}},{"content":"Direccion logica compuesta de numero de pagina y offset.","children":[],"payload":{"lines":"65,66"}}],"payload":{"lines":"63,66"}},{"content":"<strong>Ejemplo</strong>","children":[{"content":"Configuracion de memoria antes y despues de asignacion de un bloque de 16 Mbytes.","children":[],"payload":{"lines":"67,69"}}],"payload":{"lines":"66,69"}}],"payload":{"lines":"57,58"}},{"content":"Segmentacion","children":[{"content":"Subdivision de programas en segmentos, longitud variable con longitud maxima establecida.","children":[],"payload":{"lines":"70,71"}},{"content":"<strong>Direccion Generada</strong>","children":[{"content":"Compuesta de numero de segmento y offset de desplazamiento.","children":[],"payload":{"lines":"72,73"}}],"payload":{"lines":"71,73"}},{"content":"<strong>Fragmentacion</strong>","children":[{"content":"Fragmentacion interna evitada, presente fragmentacion externa.","children":[],"payload":{"lines":"74,75"}}],"payload":{"lines":"73,75"}},{"content":"<strong>Division en Segmentos</strong>","children":[{"content":"Codigo y datos, favoreciendo programacion modular.","children":[],"payload":{"lines":"76,77"}}],"payload":{"lines":"75,77"}},{"content":"<strong>Traduccion de Direcciones</strong>","children":[{"content":"Logica a fisica usando tablas de segmentos.","children":[],"payload":{"lines":"78,82"}}],"payload":{"lines":"77,82"}}],"payload":{"lines":"69,70"}}],"payload":{"lines":"1,2"}},{"colorFreezeLevel":2})</script>
</body>
</html>
